<center>代码呓语<center>

#### 20200218 周二

上周六左右开始开发小飞船，一个简单的入门小项目，跟着作者一步步码代码，
一个个小函数构建，脑袋里能逐渐形成一个脉络，明白各个函数，各个类是要做什么，
负责干什么。

小飞船到现在已创建了四个主要文件，alien_invasion.py，
整个游戏的入口和要用到的对象；ship.py，飞船文件，有一个Ship类，
控制飞船的属性，如位置移动，涉及等，还有一个update函数，
对飞船位置进行实时更新；game_functions.py文件，
游戏的大部分函数都包含在里面，目前完成的功能是通过键盘控制飞船位置左右移动；
settings.py文件，所有的配置都集中在该文件中管理，包含页面，飞船等一些属性，
如屏幕大小，背景颜色，飞船位置移动值等。慢慢的添加功能，重构代码，
越来越对这个小游戏有更深的了解，也知道了开发一个小功能活真的要细致才行，
一个小小的符号都可能报错导致程序无法正常运行。

接触这个小游戏，感觉作者一直在灌输一个思想，函数尽可能简单，
一个函数就做一件简单的事情，然后把这些简单的事情组合起来，
往后维护起来才不用太费力，别人也容易理解。
这和写自动化脚本使用PO思想有异曲同工之处，一个页面就使用一个类表示，
页面中有更多小功能就进一步拆分成各个小函数去实现，
然后流程动作通过各个对象串联起来。
***
#### 20200220 周四

今天继续编写关于子弹的射击，创建了一个Bullet类专门设计子弹。
一颗小小的子弹也要考虑到很多因素，子弹的图形，位置，速度，颜色，左右移动等，涉及的属性不少。
关键是使用了sprite中的Group类，pygame中称这个类为编组，用来存子弹用的，
具体还没有看过这个类的代码，不过功能倒是不少。因为把子弹当做一个小小的矩形，
且这个矩形跟随飞船一起移动，则屏幕更新后，更新飞船时同时也需要更新子弹，
且左右移动时也和飞船的移动一致。移动过程中进行射击，射击的路线是直线，
所以y坐标在减小，增大速度属性，减少的值越大，速度越快。发射子弹是用空格键，
则在 game_function.py 中要对原有的键盘事件进行改造。
将子弹存储到编组中和子弹的移动逻辑还是一个难点和重点，还是需要多看几遍才行。
***
#### 20200222 周六

继续修改小游戏，对子弹的射击做了进一步的优化。增加了个小功能，限制子弹数量。该功能容易
理解，重点还是那个bullets编组原理要搞懂才行。为了让代码看起更简单和容易理解，新建了
update_bullets()函数和fire_bullet()函数，自己添加了相关说明，以后看注释该容易理解。
在删除未消失的子弹功能中，出现了一个copy()函数，顺便了解了一下深浅拷贝的原理。
还要加上一个直接赋值，比较三者之间的差异。直接赋值，若b=a,a直接赋值给了b，若a内容修改的话
b会同时跟着变化，因为a,b都引用了同一个对象，本质原因是指向了同一个内存地址。  
若b=a.copy()，这是浅拷贝，看资料是说拷贝父对象，不会拷贝对象的内部的子对象。这里要
主要区分a的内容中哪个是父对象，哪个是子对象。比如a=[1,2,3,['子对象']]，拷贝了父对象，
相当于在内存中开辟了另一个空间给b，b和a的值一样，但里面都有个['子对象'],这个列表指向
的是同一个内存地址，所以，a和b不管哪个更改了['子对象']，都会导致另一个也发生改变。
若b=copy.deepcopy(a): 深度拷贝, a和b完全拷贝了父对象及其子对象，两者是完全独立的。
字面理解，深度拷贝，随便对哪个进行改变，都不会对另外一个产生影响，就酱。
***
#### 20200223 周日

pygame.init()函数总是有报错，在Pycharm中倒是没有。搜索了谷歌后尝试了方法，更糟，引出一大堆错误，郁闷。

***
#### 20200227 周四

已经创建了一个外星人了，接下来是创建一群外星人，不过从简单的的开始，先创建一行
外星人。

要想容纳一行外星人，首先要知道外星人的宽，以及屏幕的宽，两边留下的宽度和外星人
和外星人之间的间距，这些都要理清楚逻辑和公式，避免到时候外星人过于拥挤。

在game_functions.py中使用一个新的函数create_fleet()来创建第一行外星人，注意
的东西上面已经提到，在计算出可容纳的数量后，使用一个循环，每一次循环代表创建了
一个外星人，并加入aliens(Groups()编组的对象)这个编组中。

在重构阶段，把create_fleet()函数拆开进行重构，新建get_number_aliens_x()和
create_alien()两个函数。前一个把上个计算公式抽离出来，获取容纳的个数，后一个
获取了外星人相关属性后，创建了第一个外星人并放在第一行。

通过以上的重构，可以实现完整把一行外星人显示在首行。
***
#### 20200301 周日 

周六在垂直方向增加外星人，组成了外星人群。增加了get_number_rows(),修改了create_alien(),create_fleet().
垂直方向与水平方向创建外星人，有挺多相同的地方。顶上要留出空间，一个外星人宽度，外星人与外星人之间要留有空间，也是一个  
外星人宽度。外星人不能无限多行，所以与飞船之间要留有一片空白区域，才能射杀外星人。难点还是在于如何把这些转换成公式  
进行计算。由于每一行的x坐标是不变的，所以在创建的时候使用两个for循环，计算出垂直方向能容纳多少行，在每一行中再去创建  
每一个外星人。  
起初，在运行时报错，检查到screen_hight拼写少了个e，导致外星人占满了整个屏幕。这种低级的小错误要注意少犯甚至不犯。
***
#### 20200307 周六

创建了一批外星人之后，接下来就是让外星人进行移动了。起初在配置类里面设置几个属性，左右移动的速度，向下移动的速度以及
一个改变方向的标志位。先实现向右移动，然后检查外星人是否到了边缘，边缘要检查左右两边，所以到达边缘，都返回True。到达
之后，就要向下移动了，向下时只有y坐标的值增加。向下移动完，就要开始向左移动，把标志位置为-1，外星人x坐标的值减去速度，
从而向左移动。

有点疑问，当向右移动时，我想到的是检查的是最右边的外星人的x坐标是否大于等于屏幕的宽，而案例给的是  
self.rect.right >= screen_rect.right，通过right这个属性的比较，就能知道是否达到边缘，但是通过源码追踪，无法知道right
是如何来的。这些移动的过程，比较难的地方是否要把它们连贯起来，各个小动作要拆开用小函数明确的表示，然后各自调用，传入的
参数要注意它的作用。
***
#### 20200309 周日  

周六通过一个函数 pygame.sprite.groupcollide()，用来检测子弹与外星人的碰撞。groupcollide()的实现原理是遍历bullets和
aliens两个编组中的每一个元素，检查每个元素的坐标，若发现坐标一致的元素，就判断子弹和外星人重叠了，也就是碰撞到了。
groupcollide()返回一个字典，当碰撞到时，把对应的子弹和外星人加入字典中。而原来的子弹和外星人，则删除碰撞后的子弹和外星人。  
里面还需注意一个，当子弹击中外星人，子弹应该也是同时消失，而不是继续穿行到屏幕顶部，所以groupcollide()中的两个布尔值
都设置为True才合理。
```python
def groupcollide(groupa, groupb, dokilla, dokillb, collided=None):
    """detect collision between a group and another group

    pygame.sprite.groupcollide(groupa, groupb, dokilla, dokillb):
        return dict

    Given two groups, this will find the intersections between all sprites in
    each group. It returns a dictionary of all sprites in the first group that
    collide. The value for each item in the dictionary is a list of the sprites
    in the second group it collides with. The two dokill arguments control if
    the sprites from either group will be automatically removed from all
    groups. Collided is a callback function used to calculate if two sprites
    are colliding. it should take two sprites as values, and return a bool
    value indicating if they are colliding. If collided is not passed, all
    sprites must have a "rect" value, which is a rectangle of the sprite area
    that will be used to calculate the collision.

    """
    crashed = {}
    SC = spritecollide
    if dokilla:
        for s in groupa.sprites():
            c = SC(s, groupb, dokillb, collided)
            if c:
                crashed[s] = c
                s.kill()
    else:
        for s in groupa:
            c = SC(s, groupb, dokillb, collided)
            if c:
                crashed[s] = c
    return crashed
```
 ***
#### 20200321 周六

这个阶段主要检查外星人和飞船的碰撞，原理和子弹与外星人的碰撞差不多，但使用的函数是 pygame.sprite.spritecollideany()，
传递的参数是一个精灵(飞船)和一个编组(外星人),当精灵与编组发生了碰撞，就遍历编组查找与精灵碰撞的那个成员，找到后停止遍历。

当飞船与外星人发生碰撞，就意味着游戏结束，为了增加有趣性，添加了统计信息，设置飞船的数量。另外，当碰撞发生，整个射击游戏
要重置，外星人、子弹要清除剩余的数量，飞船要更新位置和生命值。

当外星人到达屏幕底端时，也判断该游戏结束，因此需要检查外星人的y坐标是否大于等于屏幕的y坐标。最后，增加一个属性game_active
来判断飞船用完后是否结束整个游戏，但check_events()都会始终执行，因为用户可能按q退出或者单击关闭窗口的按钮。  

游戏的开始和结束阶段都要思考到一些初始化和收尾的工作，假若没有书本的指导，自己是否能想到这些呢？
***
#### 20200324 周二

到了新的篇章，给游戏增加了一个Play按钮，和重构了settings.py配置文件，通过配置，改变了游戏进行中的节奏，让有些更加有趣味性。 
完成一个Play按钮，也需要注意很多细节。给Play按钮创建了一个Button类专门处理按钮动作，设置按钮的各种属性：高度、宽度、字体、
字体大小、字体位置、颜色、背景颜色等等都要提前设置好数值，假若对屏幕大小没什么概念，可能要调试很长时间才知道多少合适。
按钮上的文本被渲染为图像进行处理，方便设置它的位置。

现在要以Play按钮作为游戏开始的触发点，那么就有一个标志game_active，表示游戏前后状态的不同.当点击Play后，状态发生改变，
从不活跃状态变为活跃，于是游戏开始，等游戏结束，又把状态改为不活跃。

为了提高游戏的可玩性，适当的改变了游戏的节奏。把settings.py进行了重构，拆分为静态和动态配置。动态配置中设置了一个变量，
在每次射杀完外星人后，都会对子弹速度、飞船移动速度、外星人移动速度相应的提高，既增加了游戏的难度，也让游戏并非不可完成。

***
#### 20200404 周六

继3月24日给游戏增加了Play按钮后，最后几个章节增加了当前得分、最高得分、等级以及飞船剩余数量等一些统计信息。
当前得分、最高得分和等级都是渲染成图像后进行实时渲染在屏幕上，这样像是弄了一个积分制度，打的越多，得分越高，则等级也会越高，
但相应的，外星人移动速度会越来越快，虽然子弹射击速度也相应增加，但屏幕小，外星人一下子就到底了，所以还是修改相关设置才会
提高游戏的可持续性。

得分信息的统计主要是由Scoreboard()类完成，四个函数prep_score(),prep_high_core(),prep_level(),prep_ships()，完成对得分
最高得分，等级和飞船数量显示的功能，然后在其他涉及的函数中，主要传入sb参数，让它可以调用上面几个函数进行实时更新。

该小游戏还有许多可拓展的地方，例如增加相关场景的音效、增加爆炸效果，或者让外星人也能进行射击或者增加盾牌等等，

到这《外星人入侵》游戏已经学习完成，一个简单的小游戏做起来也要涉及很多知识，注意很多细节问题，尤其涉及到一些数量、距离的
计算，若是没有照着案例一步一步走，单凭自己摸索着开发，光是调试就要可能耗费很多时间。这个小项目，让我学习到了开发项目需要
养成一个重要的习惯，从小处着手，从一个个小功能开始搭建，比如项目前的环境准备，各种基础的开发工具，第三方库都要准备齐全；
屏幕的绘制，这是飞船，外星人，得分、等级等的基础，几乎所有对象都会用到 screen 的属性；紧接着添加一艘飞船，则飞船的图像、
位置、属性等各个方面都要设置好，在进一步去开发飞船的移动功能。总之，把大功能往下拆分，拆分的越细，越有助于理解整个项目和
运行的逻辑。

以下是对《外星人入侵游戏》的总结

目录：  

[TOC]

### settings.py

Settings 类主要对几个重要的对象进行属性配置，包括屏幕、外星人、飞船等的外观属性；另一个
重要的功能是设置游戏的节奏，通过initialize_dynamic_settings()和increase_speed()这两个
函数控制飞船、外星人、子弹在游戏中的速度及方向变化。

### alien.py

Alien 类实现单个外星人的绘制，包括外观属性、位置、移动、更新等功能。在调用的时候，通过循环
复制单个外星人的属性，可以创造一批外星人，从而减少开发量。

### alien_invasion.py

这是游戏运行的主入口，创建了相关重要的对象，包括：设置 ai_settings、屏幕 screen、飞船 ship、
子弹编组 bullets、外星人编组 aliens、统计信息 stats、Play按钮 play_button等。通过这些对象，
使用一个 while 循环，将上面的对象作为传参，调动相关函数传参开始游戏。

### bullet.py

Bullet 类是子弹对象，子弹的位置保持和飞船一致，在初始化中实现。update()函数对子弹向上移动时
进行实时更新，draw_bullet()函数在屏幕上绘制子弹的图像。

### button.py

Button 类的初始化函数定义了 Play 按钮的各项属性，然后将按钮渲染为图像展示在屏幕上，当游戏初始化
时，点击 Play 按钮即可开始。

### game_functions.py

game_functions.py 文件包含一系列函数，游戏的大部分功能都是由它们完成。其中几个主要的函数，
check_events()检查各种键盘和鼠标事件，比如飞船的移动，子弹射击，点击Play按钮，退出等；
check_bullet_alien_collisions()，检查子弹与外星人的撞击，即射击外星人，主要检查两者碰撞时
的坐标，不过这个由Pygame完成，每撞击一次，就记录一次，并记下得分，最后判断外星人是否为空，
为空则清空子弹，将等级提高，并提高相关对象的节奏，进入下一轮射击；该文件还有部分功能可以扩
展，比如添加音效或者让外星人也可以进行射击等。

### game_state.py

GameStats 类主要进行一些信息的初始化，比如飞船数量、当前得分、最高得分、游戏最初的状态等。

### scoreboard.py

Scoreboard 类对射击产生的得分进行具体实现，在屏幕上实时显示。程序把得分转为字符，并将字符
渲染为图像进行展示，包括当前得分、最高得分、等级以及飞船剩余数量，通过show_score()函数
展示各个数据。

### ship.py

Ship 类中初始化了飞船的位置，并渲染成一个图像进行展示，通过move_right，move_left两个标志控制飞船的移动
方向。





