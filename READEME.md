<center>代码呓语<center>

#### 20200218 周二

上周六左右开始开发小飞船，一个简单的入门小项目，跟着作者一步步码代码，
一个个小函数构建，脑袋里能逐渐形成一个脉络，明白各个函数，各个类是要做什么，
负责干什么。

小飞船到现在已创建了四个主要文件，alien_invasion.py，
整个游戏的入口和要用到的对象；ship.py，飞船文件，有一个Ship类，
控制飞船的属性，如位置移动，涉及等，还有一个update函数，
对飞船位置进行实时更新；game_functions.py文件，
游戏的大部分函数都包含在里面，目前完成的功能是通过键盘控制飞船位置左右移动；
settings.py文件，所有的配置都集中在该文件中管理，包含页面，飞船等一些属性，
如屏幕大小，背景颜色，飞船位置移动值等。慢慢的添加功能，重构代码，
越来越对这个小游戏有更深的了解，也知道了开发一个小功能活真的要细致才行，
一个小小的符号都可能报错导致程序无法正常运行。

接触这个小游戏，感觉作者一直在灌输一个思想，函数尽可能简单，
一个函数就做一件简单的事情，然后把这些简单的事情组合起来，
往后维护起来才不用太费力，别人也容易理解。
这和写自动化脚本使用PO思想有异曲同工之处，一个页面就使用一个类表示，
页面中有更多小功能就进一步拆分成各个小函数去实现，
然后流程动作通过各个对象串联起来。
***
#### 20200220 周四

今天继续编写关于子弹的射击，创建了一个Bullet类专门设计子弹。
一颗小小的子弹也要考虑到很多因素，子弹的图形，位置，速度，颜色，左右移动等，涉及的属性不少。
关键是使用了sprite中的Group类，pygame中称这个类为编组，用来存子弹用的，
具体还没有看过这个类的代码，不过功能倒是不少。因为把子弹当做一个小小的矩形，
且这个矩形跟随飞船一起移动，则屏幕更新后，更新飞船时同时也需要更新子弹，
且左右移动时也和飞船的移动一致。移动过程中进行射击，射击的路线是直线，
所以y坐标在减小，增大速度属性，减少的值越大，速度越快。发射子弹是用空格键，
则在 game_function.py 中要对原有的键盘事件进行改造。
将子弹存储到编组中和子弹的移动逻辑还是一个难点和重点，还是需要多看几遍才行。
***
#### 20200222 周六

继续修改小游戏，对子弹的射击做了进一步的优化。增加了个小功能，限制子弹数量。该功能容易
理解，重点还是那个bullets编组原理要搞懂才行。为了让代码看起更简单和容易理解，新建了
update_bullets()函数和fire_bullet()函数，自己添加了相关说明，以后看注释该容易理解。
在删除未消失的子弹功能中，出现了一个copy()函数，顺便了解了一下深浅拷贝的原理。
还要加上一个直接赋值，比较三者之间的差异。直接赋值，若b=a,a直接赋值给了b，若a内容修改的话
b会同时跟着变化，因为a,b都引用了同一个对象，本质原因是指向了同一个内存地址。  
若b=a.copy()，这是浅拷贝，看资料是说拷贝父对象，不会拷贝对象的内部的子对象。这里要
主要区分a的内容中哪个是父对象，哪个是子对象。比如a=[1,2,3,['子对象']]，拷贝了父对象，
相当于在内存中开辟了另一个空间给b，b和a的值一样，但里面都有个['子对象'],这个列表指向
的是同一个内存地址，所以，a和b不管哪个更改了['子对象']，都会导致另一个也发生改变。
若b=copy.deepcopy(a): 深度拷贝, a和b完全拷贝了父对象及其子对象，两者是完全独立的。
字面理解，深度拷贝，随便对哪个进行改变，都不会对另外一个产生影响，就酱。
***
#### 20200223 周日

pygame.init()函数总是有报错，在Pycharm中倒是没有。搜索了谷歌后尝试了方法，更糟，引出一大堆错误，郁闷。

***
#### 20200227 周四

已经创建了一个外星人了，接下来是创建一群外星人，不过从简单的的开始，先创建一行
外星人。

要想容纳一行外星人，首先要知道外星人的宽，以及屏幕的宽，两边留下的宽度和外星人
和外星人之间的间距，这些都要理清楚逻辑和公式，避免到时候外星人过于拥挤。

在game_functions.py中使用一个新的函数create_fleet()来创建第一行外星人，注意
的东西上面已经提到，在计算出可容纳的数量后，使用一个循环，每一次循环代表创建了
一个外星人，并加入aliens(Groups()编组的对象)这个编组中。

在重构阶段，把create_fleet()函数拆开进行重构，新建get_number_aliens_x()和
create_alien()两个函数。前一个把上个计算公式抽离出来，获取容纳的个数，后一个
获取了外星人相关属性后，创建了第一个外星人并放在第一行。

通过以上的重构，可以实现完整把一行外星人显示在首行。
***
#### 20200301 周日 

周六在垂直方向增加外星人，组成了外星人群。增加了get_number_rows(),修改了create_alien(),create_fleet().
垂直方向与水平方向创建外星人，有挺多相同的地方。顶上要留出空间，一个外星人宽度，外星人与外星人之间要留有空间，也是一个  
外星人宽度。外星人不能无限多行，所以与飞船之间要留有一片空白区域，才能射杀外星人。难点还是在于如何把这些转换成公式  
进行计算。由于每一行的x坐标是不变的，所以在创建的时候使用两个for循环，计算出垂直方向能容纳多少行，在每一行中再去创建  
每一个外星人。  
起初，在运行时报错，检查到screen_hight拼写少了个e，导致外星人占满了整个屏幕。这种低级的小错误要注意少犯甚至不犯。
***
#### 20200307 周六

创建了一批外星人之后，接下来就是让外星人进行移动了。起初在配置类里面设置几个属性，左右移动的速度，向下移动的速度以及
一个改变方向的标志位。先实现向右移动，然后检查外星人是否到了边缘，边缘要检查左右两边，所以到达边缘，都返回True。到达
之后，就要向下移动了，向下时只有y坐标的值增加。向下移动完，就要开始向左移动，把标志位置为-1，外星人x坐标的值减去速度，
从而向左移动。

有点疑问，当向右移动时，我想到的是检查的是最右边的外星人的x坐标是否大于等于屏幕的宽，而案例给的是  
self.rect.right >= screen_rect.right，通过right这个属性的比较，就能知道是否达到边缘，但是通过源码追踪，无法知道right
是如何来的。这些移动的过程，比较难的地方是否要把它们连贯起来，各个小动作要拆开用小函数明确的表示，然后各自调用，传入的
参数要注意它的作用。
***
#### 20200309 周日  

周六通过一个函数 pygame.sprite.groupcollide()，用来检测子弹与外星人的碰撞。groupcollide()的实现原理是遍历bullets和
aliens两个编组中的每一个元素，检查每个元素的坐标，若发现坐标一致的元素，就判断子弹和外星人重叠了，也就是碰撞到了。
groupcollide()返回一个字典，当碰撞到时，把对应的子弹和外星人加入字典中。而原来的子弹和外星人，则删除碰撞后的子弹和外星人。  
里面还需注意一个，当子弹击中外星人，子弹应该也是同时消失，而不是继续穿行到屏幕顶部，所以groupcollide()中的两个布尔值
都设置为True才合理。
```python
def groupcollide(groupa, groupb, dokilla, dokillb, collided=None):
    """detect collision between a group and another group

    pygame.sprite.groupcollide(groupa, groupb, dokilla, dokillb):
        return dict

    Given two groups, this will find the intersections between all sprites in
    each group. It returns a dictionary of all sprites in the first group that
    collide. The value for each item in the dictionary is a list of the sprites
    in the second group it collides with. The two dokill arguments control if
    the sprites from either group will be automatically removed from all
    groups. Collided is a callback function used to calculate if two sprites
    are colliding. it should take two sprites as values, and return a bool
    value indicating if they are colliding. If collided is not passed, all
    sprites must have a "rect" value, which is a rectangle of the sprite area
    that will be used to calculate the collision.

    """
    crashed = {}
    SC = spritecollide
    if dokilla:
        for s in groupa.sprites():
            c = SC(s, groupb, dokillb, collided)
            if c:
                crashed[s] = c
                s.kill()
    else:
        for s in groupa:
            c = SC(s, groupb, dokillb, collided)
            if c:
                crashed[s] = c
    return crashed
```
 ***
#### 20200321 周六

这个阶段主要检查外星人和飞船的碰撞，原理和子弹与外星人的碰撞差不多，但使用的函数是 pygame.sprite.spritecollideany()，
传递的参数是一个精灵(飞船)和一个编组(外星人),当精灵与编组发生了碰撞，就遍历编组查找与精灵碰撞的那个成员，找到后停止遍历。

当飞船与外星人发生碰撞，就意味着游戏结束，为了增加有趣性，添加了统计信息，设置飞船的数量。另外，当碰撞发生，整个射击游戏
要重置，外星人、子弹要清除剩余的数量，飞船要更新位置和生命值。

当外星人到达屏幕底端时，也判断该游戏结束，因此需要检查外星人的y坐标是否大于等于屏幕的y坐标。最后，增加一个属性game_active
来判断飞船用完后是否结束整个游戏，但check_events()都会始终执行，因为用户可能按q退出或者单击关闭窗口的按钮。  

游戏的开始和结束阶段都要思考到一些初始化和收尾的工作，假若没有书本的指导，自己是否能想到这些呢？
***
#### 20200324 周二

到了新的篇章，给游戏增加了一个Play按钮，和重构了settings.py配置文件，通过配置，改变了游戏进行中的节奏，让有些更加有趣味性。 
完成一个Play按钮，也需要注意很多细节。给Play按钮创建了一个Button类专门处理按钮动作，设置按钮的各种属性：高度、宽度、字体、
字体大小、字体位置、颜色、背景颜色等等都要提前设置好数值，假若对屏幕大小没什么概念，可能要调试很长时间才知道多少合适。
按钮上的文本被渲染为图像进行处理，方便设置它的位置。

现在要以Play按钮作为游戏开始的触发点，那么就有一个标志game_active，表示游戏前后状态的不同.当点击Play后，状态发生改变，
从不活跃状态变为活跃，于是游戏开始，等游戏结束，又把状态改为不活跃。

为了提高游戏的可玩性，适当的改变了游戏的节奏。把settings.py进行了重构，拆分为静态和动态配置。动态配置中设置了一个变量，
在每次射杀完外星人后，都会对子弹速度、飞船移动速度、外星人移动速度相应的提高，既增加了游戏的难度，也让游戏并非不可完成。